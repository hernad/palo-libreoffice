/*
 * ExternalDataDialog.java
 *
 * Palo Open Office Calc AddIn
 * Copyright (C) 2008 PalOOCa Team,  Tensegrity Software GmbH, 2009

 * The software is licensed under an Open-Source License (GPL).
 * If you want to redistribute the software you must observe the regulations of
 * the GPL . If you want to redistribute the software without the
 * restrictions of the GPL, you have to contact Tensegrity Software GmbH
 * (Tensegrity) for written consent to do so.
 * Tensegrity may offer commercial licenses for redistribution (Dual Licensing)
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Created on 31/05/2010, 11:52:16 AM
 */

package org.palooca.dialogs;

import org.palooca.dataimport.ExternalDataHandler;
import com.sun.star.uno.XComponentContext;
import java.awt.Cursor;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import org.palooca.PalOOCaManager;
import org.palooca.dataimport.ImportResult;

/**
 *
 * @author Pieter van der Merwe
 */
public class ExternalDataDialog extends javax.swing.JDialog
        implements PropertyChangeListener {

    private XComponentContext context;
    private PalOOCaManager manager;
    private ExternalDataHandler externalDataHandler;
    private ImportFunctionsDialog importFunctionsDialog;
    private FinishAll finishAllThread = null;

    /** Creates new form ExternalDataDialog */
    public ExternalDataDialog(java.awt.Frame parent, boolean modal, XComponentContext context) {
        super(parent, modal);

        this.context = context;
        this.manager = PalOOCaManager.getInstance(context);

        this.importFunctionsDialog = new ImportFunctionsDialog(this, true, context);

        initComponents();
        setLocationRelativeTo(null);
    }

    /**
     * Sets up the import method.  Currently only supports import from file, but in future could
     * support more methods
     * @return If the import was setup successfully.
     */
    public boolean SetupImport(){
        externalDataHandler = null;

        ExternalFileDialog fileDialog = new ExternalFileDialog(null, true, this.context);
        fileDialog.setAlwaysOnTop(true);
        fileDialog.setVisible(true);

        if (fileDialog.getModalResult() == JOptionPane.CANCEL_OPTION)
            return false;

        externalDataHandler = fileDialog;

        externalDataHandler.beginImport();

        refreshScreen();
        validateButtons();

        return true;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        chbExecAllImpFunc = new javax.swing.JCheckBox();
        pgbProgress = new javax.swing.JProgressBar();
        lblEntry = new javax.swing.JLabel();
        txtEntryNum = new javax.swing.JTextField();
        btnNext = new javax.swing.JButton();
        btnImportFunc = new javax.swing.JButton();
        btnClose = new javax.swing.JButton();
        lblOf = new javax.swing.JLabel();
        txtEntryTotal = new javax.swing.JTextField();
        btnFinish = new javax.swing.JButton();
        chbRefreshScreen = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("org/palooca/dialogs/PalOOCaDialogs"); // NOI18N
        setTitle(bundle.getString("ExternalDataImport")); // NOI18N
        setFocusableWindowState(false);
        setIconImage(null);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        chbExecAllImpFunc.setText(bundle.getString("ExecuteAllImportFunctions")); // NOI18N
        chbExecAllImpFunc.setName("chbExecAllImpFunc"); // NOI18N
        chbExecAllImpFunc.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chbExecAllImpFuncActionPerformed(evt);
            }
        });

        pgbProgress.setFocusable(false);
        pgbProgress.setName("pgbProgress"); // NOI18N
        pgbProgress.setStringPainted(true);

        lblEntry.setText(bundle.getString("EntryNumLabel")); // NOI18N
        lblEntry.setName("lblEntry"); // NOI18N

        txtEntryNum.setEditable(false);
        txtEntryNum.setText("0");
        txtEntryNum.setName("txtEntryNum"); // NOI18N

        btnNext.setText(bundle.getString("Next")); // NOI18N
        btnNext.setName("btnNext"); // NOI18N
        btnNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNextActionPerformed(evt);
            }
        });

        btnImportFunc.setText(bundle.getString("ExecuteImportFunctions")); // NOI18N
        btnImportFunc.setName("btnImportFunc"); // NOI18N
        btnImportFunc.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnImportFuncActionPerformed(evt);
            }
        });

        btnClose.setText(bundle.getString("Close")); // NOI18N
        btnClose.setName("btnClose"); // NOI18N
        btnClose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCloseActionPerformed(evt);
            }
        });

        lblOf.setText("/");
        lblOf.setName("lblOf"); // NOI18N

        txtEntryTotal.setEditable(false);
        txtEntryTotal.setText("0");
        txtEntryTotal.setName("txtEntryTotal"); // NOI18N

        btnFinish.setText(bundle.getString("Finish")); // NOI18N
        btnFinish.setName("btnFinish"); // NOI18N
        btnFinish.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFinishActionPerformed(evt);
            }
        });

        chbRefreshScreen.setText(bundle.getString("RefreshingScreenWhileFinishing")); // NOI18N
        chbRefreshScreen.setName("chbRefreshScreen"); // NOI18N

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(pgbProgress, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 528, Short.MAX_VALUE)
                    .add(layout.createSequentialGroup()
                        .add(lblEntry)
                        .add(4, 4, 4)
                        .add(txtEntryNum, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 62, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(lblOf, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 10, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(txtEntryTotal, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 62, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(chbExecAllImpFunc, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 528, Short.MAX_VALUE)
                    .add(chbRefreshScreen)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                        .add(btnNext)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(btnFinish)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(btnImportFunc)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 122, Short.MAX_VALUE)
                        .add(btnClose)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(lblEntry)
                    .add(txtEntryNum, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(txtEntryTotal, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(lblOf))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(pgbProgress, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(chbExecAllImpFunc)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .add(chbRefreshScreen)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(btnNext)
                    .add(btnFinish)
                    .add(btnImportFunc)
                    .add(btnClose))
                .add(16, 16, 16))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNextActionPerformed
        disableScreen();
        this.getNextLine();
        enableScreen();
    }//GEN-LAST:event_btnNextActionPerformed

    private void btnFinishActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFinishActionPerformed
        finishAllThread = new FinishAll();
        finishAllThread.addPropertyChangeListener(this);
        finishAllThread.execute();
    }//GEN-LAST:event_btnFinishActionPerformed

    private void btnImportFuncActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImportFuncActionPerformed
        this.ExecuteImportFunctions();
    }//GEN-LAST:event_btnImportFuncActionPerformed

    private void btnCloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCloseActionPerformed
        closeForm();
    }//GEN-LAST:event_btnCloseActionPerformed

    private void closeForm(){

        // If the finish all function is running, 
        // confirm if the user wants to exit
        if (finishAllThread != null
                && ! finishAllThread.isDone())
        {

            if (JOptionPane.showConfirmDialog(this,
                java.util.ResourceBundle.getBundle("org/palooca/dialogs/PalOOCaDialogs").getString("CancelExternalImport?"),
                java.util.ResourceBundle.getBundle("org/palooca/dialogs/PalOOCaDialogs").getString("Confirmation"),
                JOptionPane.YES_NO_CANCEL_OPTION) == JOptionPane.YES_OPTION)
                finishAllThread.cancel(true);
            else 
                return;
        }

        if (externalDataHandler != null)
            externalDataHandler.endImport();

        this.dispose();
    }

    private void chbExecAllImpFuncActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chbExecAllImpFuncActionPerformed
        btnImportFunc.setEnabled(! chbExecAllImpFunc.isSelected());
    }//GEN-LAST:event_chbExecAllImpFuncActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        closeForm();
    }//GEN-LAST:event_formWindowClosing

    private void ExecuteImportFunctions(){
        importFunctionsDialog.resetState();

        if (chbExecAllImpFunc.isSelected())
            importFunctionsDialog.setStateProcessAll();
        
        ImportResult.beginImport(importFunctionsDialog);
        manager.recalculateDocument(); //do the actual import
        ImportResult.endImport();
        manager.recalculateDocument(); //update all other fields
    }

    private void disableScreen(){
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

        btnFinish.setEnabled(false);
        btnImportFunc.setEnabled(false);
        btnNext.setEnabled(false);
        chbExecAllImpFunc.setEnabled(false);
        chbRefreshScreen.setEnabled(false);
    }

    private void enableScreen(){
        setCursor(Cursor.getDefaultCursor());

        refreshScreen();

        validateButtons();

    }

    private void getNextLine(){
        if (chbExecAllImpFunc.isSelected()){
            importFunctionsDialog.resetState();
            importFunctionsDialog.setStateProcessAll();

            if (ImportResult.getUseResultCache() == true)
                // All previous import functions will be recalculated with new values,
                // previous cache doesn't matter.
                ImportResult.clearCache();

            ImportResult.beginImport(importFunctionsDialog);
        }

        this.externalDataHandler.doEntryImport();

        if (chbExecAllImpFunc.isSelected()){
            ImportResult.endImport();
            if (chbRefreshScreen.isSelected())
                manager.recalculateDocument(); // Recalculate sheets
        }
    }

    private void refreshScreen(){
        txtEntryTotal.setText(Integer.toString(externalDataHandler.getTotalEntryNum()));
        txtEntryNum.setText(Integer.toString(externalDataHandler.getCurrentEntryNum()));

        float val = 1.00f * externalDataHandler.getCurrentEntryNum() / externalDataHandler.getTotalEntryNum();
        val = val * pgbProgress.getMaximum();
        pgbProgress.setValue(Math.round(val));

    }

    private void validateButtons(){
        btnClose.setEnabled(true);
        chbExecAllImpFunc.setEnabled(true);
        chbRefreshScreen.setEnabled(true);

        if (externalDataHandler == null){
            btnFinish.setEnabled(false);
            btnImportFunc.setEnabled(false);
            btnNext.setEnabled(false);
            return;
        }

        if (externalDataHandler.hasMoreEntries()){
            btnFinish.setEnabled(true);
            btnNext.setEnabled(true);
        }
        else{
            btnFinish.setEnabled(false);
            btnNext.setEnabled(false);
        }

        if (chbExecAllImpFunc.isSelected() == true)
            btnImportFunc.setEnabled(false);
        else
           btnImportFunc.setEnabled(true);

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnClose;
    private javax.swing.JButton btnFinish;
    private javax.swing.JButton btnImportFunc;
    private javax.swing.JButton btnNext;
    private javax.swing.JCheckBox chbExecAllImpFunc;
    private javax.swing.JCheckBox chbRefreshScreen;
    private javax.swing.JLabel lblEntry;
    private javax.swing.JLabel lblOf;
    private javax.swing.JProgressBar pgbProgress;
    private javax.swing.JTextField txtEntryNum;
    private javax.swing.JTextField txtEntryTotal;
    // End of variables declaration//GEN-END:variables

    public void propertyChange(PropertyChangeEvent evt) {
        refreshScreen();
    }

    /**
     * Worker thread for the Finish All process where the dialog
     * screen needs to be refreshed with the status
     */
    class FinishAll extends SwingWorker<Void, Void>{

        @Override
        protected Void doInBackground() throws Exception {
            int counter = 0;
            disableScreen();

            // Your changes of utilizing cache with an external import becomes remote.  Cahing slows down the
            // process.  If we need to refresh the screen we need to cache the result so it can be refetched when the screen
            // is being recaclulated.
            if (chbRefreshScreen.isSelected() == false)
                ImportResult.setUseResultCache(false);

            try{
                while (externalDataHandler.hasMoreEntries()){
                    counter = counter + 1;
                    if (counter == 100)
                        counter = 1;

                    // Cache the last entry so it is avaiable after the screen is closed
                    if (externalDataHandler.getTotalEntryNum() - externalDataHandler.getCurrentEntryNum() == 1)
                        ImportResult.setUseResultCache(true);

                    getNextLine();

                    setProgress(counter);
                }
            }
            finally{
                enableScreen();
            }

            return null;
        }
    }
}
